KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid<- function(b_shape,b_rate, g_shape, g_rate, prior_vec){
no.d<-5
clin_param<-rgamma(10000,b_shape,b_rate)
pat_param<-rgamma(10000, g_shape, g_rate)
clin_rec<-sapply(1:10000, function (k) which.min(abs(skeletonc^clin_param[k]-0.25)))
pat_rec<-sapply(1:10000, function (k) which.min(abs(skeletonp^pat_param[k]-0.35)))
proposal<-table(pmin(clin_rec, pat_rec))/10000
kl<-sum(sapply(1:5, function(k) proposal[k]*log((1/prior_vec[k])*proposal[k])))
return(kl)
}
input
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
KL_grid(seq(from=0.01, to =3, length.out=10)[7],seq(from=0.01, to =3, length.out=10)[6],seq(from=0.01, to =3, length.out=10)[10],seq(from=0.01, to =3, length.out=10)[9], prior_vec)
setwd("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch")
setwd("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch")
sc1 <- read.csv("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch/sc1.csv")
View(sc1)
sc1 <- eval(parse(text='read.csv("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch/sc',scenario,'.csv")'))
scenario<-1
sc1 <- eval(parse(text='read.csv("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch/sc',scenario,'.csv")'))
sc1 <- eval(parse(text=paste0('read.csv("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch/sc',scenario,'.csv")')))
library(tidyverse)
set.seed(1001)
setwd("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch")
scenario<-1
sc <- eval(parse(text=paste0('read.csv("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch/sc',scenario,'.csv")')))
# --- your fixed inputs (unchanged) ---
sc1 <- c(0.35, 0.30, 0.20, 0.10, 0.05)
sc2 <- c(0.10, 0.15, 0.20, 0.25, 0.30)
sc3 <- c(0.10, 0.20, 0.40, 0.20, 0.10)
sc4 <- c(0.20, 0.20, 0.20, 0.20, 0.20)
b_shape <- as.numeric(collect_results[4, 3])
b_rate  <- as.numeric(collect_results[4, 4])
g_shape <- as.numeric(collect_results[4, 5])
sc
b_shape <- as.numeric(sc[1, 3])
b_rate  <- as.numeric(sc[1, 4])
g_shape <- as.numeric(sc[1, 5])
g_rate  <- as.numeric(sc[1, 6])
b_shape
b_rate
sc
b_shape <- as.numeric(sc[1, 4])
b_rate  <- as.numeric(sc[1, 5])
g_shape <- as.numeric(sc[1, 6])
g_rate  <- as.numeric(sc[1, 7])
no.d <- 5
# --- compute proposal (tidy style) ---
clin_param <- rgamma(10000, b_shape, b_rate)
pat_param  <- rgamma(10000, g_shape, g_rate)
clin_rec <- map_int(clin_param, ~ which.min(abs(skeletonc^.x - 0.25)))
pat_rec  <- map_int(pat_param,  ~ which.min(abs(skeletonp^.x - 0.35)))
# pmin -> pick the minimum of the two recovery indices, then tabulate to proportions
min_rec <- pmin(clin_rec, pat_rec)
proposal_props <- tabulate(min_rec, nbins = no.d) / length(min_rec)
# Create tidy data frames for plotting
plot_df <- tibble(
cat = factor(1:no.d, labels = paste0("d", 1:no.d)),
proposal = proposal_props
)
plot_df
# Create tidy data frames for plotting
plot_df <- tibble(
cat = factor(1:no.d, labels = paste0("d", 1:no.d)),
proposal = proposal_props
)
# Create tidy data frames for plotting
plot_df <- tibble(
cat = factor(1:no.d, labels = paste0("d", 1:no.d)),
proposal = proposal_props
)
sc_df <- tibble(
cat = factor(1:no.d, labels = paste0("d", 1:no.d)),
sc2 = eval(parse(text=paste0("sc",scenario)))
)
sc_df <- tibble(
cat = factor(1:no.d, labels = paste0("d", 1:no.d)),
sc = eval(parse(text=paste0("sc",scenario)))
)
# --- ggplot: white bars with black border, red semi-transparent overlay ---
ggplot(plot_df, aes(x = cat, y = proposal)) +
geom_col(fill = "#8DA0CB", alpha = 0.45) +               # base bars: white fill, black border
geom_col(data = sc_df, aes(x = cat, y = sc2),                         # overlay bars
color="black", fill="white", alpha = 0, position = "identity") +
scale_y_continuous(limits = c(0, 1)) +
labs(title = "",
x = "Category", y = "Proportion") +
theme_minimal() +
theme(panel.grid.major.x = element_blank())
sc
# --- ggplot: white bars with black border, red semi-transparent overlay ---
ggplot(plot_df, aes(x = cat, y = proposal)) +
geom_col(fill = "#8DA0CB", alpha = 0.45) +               # base bars: white fill, black border
geom_col(data = sc_df, aes(x = cat, y = sc),                         # overlay bars
color="black", fill="white", alpha = 0, position = "identity") +
scale_y_continuous(limits = c(0, 1)) +
labs(title = "",
x = "Category", y = "Proportion") +
theme_minimal() +
theme(panel.grid.major.x = element_blank())
library(tidyverse)
set.seed(1001)
setwd("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch")
scenario<-2
sc <- eval(parse(text=paste0('read.csv("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch/sc',scenario,'.csv")')))
# --- your fixed inputs (unchanged) ---
sc1 <- c(0.35, 0.30, 0.20, 0.10, 0.05)
sc2 <- c(0.10, 0.15, 0.20, 0.25, 0.30)
sc3 <- c(0.10, 0.20, 0.40, 0.20, 0.10)
sc4 <- c(0.20, 0.20, 0.20, 0.20, 0.20)
b_shape <- as.numeric(sc[1, 4])
b_rate  <- as.numeric(sc[1, 5])
g_shape <- as.numeric(sc[1, 6])
g_rate  <- as.numeric(sc[1, 7])
no.d <- 5
# --- compute proposal (tidy style) ---
clin_param <- rgamma(10000, b_shape, b_rate)
pat_param  <- rgamma(10000, g_shape, g_rate)
clin_rec <- map_int(clin_param, ~ which.min(abs(skeletonc^.x - 0.25)))
pat_rec  <- map_int(pat_param,  ~ which.min(abs(skeletonp^.x - 0.35)))
# pmin -> pick the minimum of the two recovery indices, then tabulate to proportions
min_rec <- pmin(clin_rec, pat_rec)
proposal_props <- tabulate(min_rec, nbins = no.d) / length(min_rec)
# Create tidy data frames for plotting
plot_df <- tibble(
cat = factor(1:no.d, labels = paste0("d", 1:no.d)),
proposal = proposal_props
)
sc_df <- tibble(
cat = factor(1:no.d, labels = paste0("d", 1:no.d)),
sc = eval(parse(text=paste0("sc",scenario)))
)
# --- ggplot: white bars with black border, red semi-transparent overlay ---
ggplot(plot_df, aes(x = cat, y = proposal)) +
geom_col(fill = "#8DA0CB", alpha = 0.45) +               # base bars: white fill, black border
geom_col(data = sc_df, aes(x = cat, y = sc),                         # overlay bars
color="black", fill="white", alpha = 0, position = "identity") +
scale_y_continuous(limits = c(0, 1)) +
labs(title = "",
x = "Category", y = "Proportion") +
theme_minimal() +
theme(panel.grid.major.x = element_blank())
library(tidyverse)
set.seed(1001)
setwd("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch")
scenario<-3
sc <- eval(parse(text=paste0('read.csv("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch/sc',scenario,'.csv")')))
# --- your fixed inputs (unchanged) ---
sc1 <- c(0.35, 0.30, 0.20, 0.10, 0.05)
sc2 <- c(0.10, 0.15, 0.20, 0.25, 0.30)
sc3 <- c(0.10, 0.20, 0.40, 0.20, 0.10)
sc4 <- c(0.20, 0.20, 0.20, 0.20, 0.20)
b_shape <- as.numeric(sc[1, 4])
b_rate  <- as.numeric(sc[1, 5])
g_shape <- as.numeric(sc[1, 6])
g_rate  <- as.numeric(sc[1, 7])
no.d <- 5
# --- compute proposal (tidy style) ---
clin_param <- rgamma(10000, b_shape, b_rate)
pat_param  <- rgamma(10000, g_shape, g_rate)
clin_rec <- map_int(clin_param, ~ which.min(abs(skeletonc^.x - 0.25)))
pat_rec  <- map_int(pat_param,  ~ which.min(abs(skeletonp^.x - 0.35)))
# pmin -> pick the minimum of the two recovery indices, then tabulate to proportions
min_rec <- pmin(clin_rec, pat_rec)
proposal_props <- tabulate(min_rec, nbins = no.d) / length(min_rec)
# Create tidy data frames for plotting
plot_df <- tibble(
cat = factor(1:no.d, labels = paste0("d", 1:no.d)),
proposal = proposal_props
)
sc_df <- tibble(
cat = factor(1:no.d, labels = paste0("d", 1:no.d)),
sc = eval(parse(text=paste0("sc",scenario)))
)
# --- ggplot: white bars with black border, red semi-transparent overlay ---
ggplot(plot_df, aes(x = cat, y = proposal)) +
geom_col(fill = "#8DA0CB", alpha = 0.45) +               # base bars: white fill, black border
geom_col(data = sc_df, aes(x = cat, y = sc),                         # overlay bars
color="black", fill="white", alpha = 0, position = "identity") +
scale_y_continuous(limits = c(0, 1)) +
labs(title = "",
x = "Category", y = "Proportion") +
theme_minimal() +
theme(panel.grid.major.x = element_blank())
library(tidyverse)
set.seed(1001)
setwd("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch")
scenario<-4
sc <- eval(parse(text=paste0('read.csv("C:/Users/ealger/OneDrive - The Institute of Cancer Research/M/PhD/Trial Designs/calibrate_priors/Statistics in Medicine/revision/code/calibrate_priors/results/gridsearch/sc',scenario,'.csv")')))
# --- your fixed inputs (unchanged) ---
sc1 <- c(0.35, 0.30, 0.20, 0.10, 0.05)
sc2 <- c(0.10, 0.15, 0.20, 0.25, 0.30)
sc3 <- c(0.10, 0.20, 0.40, 0.20, 0.10)
sc4 <- c(0.20, 0.20, 0.20, 0.20, 0.20)
b_shape <- as.numeric(sc[1, 4])
b_rate  <- as.numeric(sc[1, 5])
g_shape <- as.numeric(sc[1, 6])
g_rate  <- as.numeric(sc[1, 7])
no.d <- 5
# --- compute proposal (tidy style) ---
clin_param <- rgamma(10000, b_shape, b_rate)
pat_param  <- rgamma(10000, g_shape, g_rate)
clin_rec <- map_int(clin_param, ~ which.min(abs(skeletonc^.x - 0.25)))
pat_rec  <- map_int(pat_param,  ~ which.min(abs(skeletonp^.x - 0.35)))
# pmin -> pick the minimum of the two recovery indices, then tabulate to proportions
min_rec <- pmin(clin_rec, pat_rec)
proposal_props <- tabulate(min_rec, nbins = no.d) / length(min_rec)
# Create tidy data frames for plotting
plot_df <- tibble(
cat = factor(1:no.d, labels = paste0("d", 1:no.d)),
proposal = proposal_props
)
sc_df <- tibble(
cat = factor(1:no.d, labels = paste0("d", 1:no.d)),
sc = eval(parse(text=paste0("sc",scenario)))
)
# --- ggplot: white bars with black border, red semi-transparent overlay ---
ggplot(plot_df, aes(x = cat, y = proposal)) +
geom_col(fill = "#8DA0CB", alpha = 0.45) +               # base bars: white fill, black border
geom_col(data = sc_df, aes(x = cat, y = sc),                         # overlay bars
color="black", fill="white", alpha = 0, position = "identity") +
scale_y_continuous(limits = c(0, 1)) +
labs(title = "",
x = "Category", y = "Proportion") +
theme_minimal() +
theme(panel.grid.major.x = element_blank())
KL_grid<- function(b_shape,b_rate, g_shape, g_rate, prior_vec){
no.d<-5
clin_param<-rgamma(1000,b_shape,b_rate)
pat_param<-rgamma(1000, g_shape, g_rate)
clin_rec<-sapply(1:1000, function (k) which.min(abs(skeletonc^clin_param[k]-0.25)))
pat_rec<-sapply(1:1000, function (k) which.min(abs(skeletonp^pat_param[k]-0.35)))
proposal<-table(pmin(clin_rec, pat_rec))/1000
kl<-sum(sapply(1:5, function(k) proposal[k]*log((1/prior_vec[k])*proposal[k])))
return(kl)
}
KL_grid(b_shape, b_rate, g_shape, g_rate, eval(parse(text=paste0("sc",scenario))))
KL_grid(b_shape, b_rate, g_shape, g_rate, eval(parse(text=paste0("sc",scenario))))
KL_grid(b_shape, b_rate, g_shape, g_rate, eval(parse(text=paste0("sc",scenario))))
?optim
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B")
nm$counts
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", abstol=e-10)
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", abstol=1e-10)
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(factr = 1e-10), maxit=22)
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(factr = 1e-10,maxit=22))
nm
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(factr = 1e-10,maxit=100))
nm
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(factr = 1e-10,maxit=10))
nm
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(factr = 1e-5,maxit=10))
nm
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(factr = 1e-5,maxit=1000))
nm
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(abstol = 1e-5,maxit=1000))
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(maxit=1000))
nm
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(maxit=10))
nm
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(maxit=5))
nm
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(maxit=2))
nm
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(maxit=1))
nm
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(maxfun=1))
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01),  maxfun=1)
nm<-optim(par=c(1,1,1,1), KL, no.d=5, Hset_b=clin, Hset_g=pat, prior_vec=prior_vec, lower=c(0,0.1,0,rate[i]), upper=c(10,10,10,rate[i]+0.01), method="L-BFGS-B", control = list(maxit=1))
nm
?nlminb
start_par <- c(1,1,1,1)
res <- nlminb(
start = start_par,
objective = KL,
lower = c(0, 0.1, 0, rate[i]),
upper = c(10, 10, 10, rate[i] + 0.01),
control = list(
iter.max = 1,    # analogous to maxit
eval.max = 5000, # maximum objective evaluations (if you want a cap)
rel.tol = 1e-8   # relative tolerance
),
# additional arguments passed to KL(...)
no.d = 5,
Hset_b = clin,
Hset_g = pat,
prior_vec = prior_vec
)
# inspect result
names(res)
res$par         # fitted parameters
res$objective   # final objective value
res$iterations  # number of iterations used
res$evaluations # counts of function/gradient evaluations (usually a named vector)
res$convergence # 0 typically means success
start_par <- c(1,1,1,1)
res <- nlminb(
start = start_par,
objective = KL,
lower = c(0, 0.1, 0, rate[i]),
upper = c(10, 10, 10, rate[i] + 0.01),
control = list(
iter.max = 5,    # analogous to maxit
eval.max = 5000, # maximum objective evaluations (if you want a cap)
rel.tol = 1e-8   # relative tolerance
),
# additional arguments passed to KL(...)
no.d = 5,
Hset_b = clin,
Hset_g = pat,
prior_vec = prior_vec
)
# inspect result
names(res)
res$par         # fitted parameters
res$objective   # final objective value
res$iterations  # number of iterations used
res$evaluations # counts of function/gradient evaluations (usually a named vector)
res$convergence # 0 typically means success
start_par <- c(1,1,1,1)
res <- nlminb(
start = start_par,
objective = KL,
lower = c(0, 0.1, 0, rate[i]),
upper = c(10, 10, 10, rate[i] + 0.01),
control = list(
iter.max = 22,    # analogous to maxit
eval.max = 5000, # maximum objective evaluations (if you want a cap)
rel.tol = 1e-8   # relative tolerance
),
# additional arguments passed to KL(...)
no.d = 5,
Hset_b = clin,
Hset_g = pat,
prior_vec = prior_vec
)
# inspect result
names(res)
res$par         # fitted parameters
res$objective   # final objective value
res$iterations  # number of iterations used
res$evaluations # counts of function/gradient evaluations (usually a named vector)
res$convergence # 0 typically means success
start_par <- c(1,1,1,1)
res <- nlminb(
start = start_par,
objective = KL,
lower = c(0, 0.1, 0, rate[i]),
upper = c(10, 10, 10, rate[i] + 0.01),
control = list(
iter.max = 50,    # analogous to maxit
eval.max = 5000, # maximum objective evaluations (if you want a cap)
rel.tol = 1e-8   # relative tolerance
),
# additional arguments passed to KL(...)
no.d = 5,
Hset_b = clin,
Hset_g = pat,
prior_vec = prior_vec
)
# inspect result
names(res)
res$par         # fitted parameters
res$objective   # final objective value
res$iterations  # number of iterations used
res$evaluations # counts of function/gradient evaluations (usually a named vector)
res$convergence # 0 typically means success
t.opt<-system.time(
nm <- nlminb(
start = start_par,
objective = KL,
lower = c(0, 0.1, 0, rate[i]),
upper = c(10, 10, 10, rate[i] + 0.01),
control = list(iter.max = 50,eval.max = 5000, rel.tol = 1e-8),
no.d = 5,Hset_b = clin,Hset_g = pat,prior_vec = prior_vec)
)
nm
nm$par
collect_results[2,]<-c("opt", j, unlist(nm$par), nm$objective, run_time_opt)
collect_results
3^4
c.shape<- seq(from=0.01, to =3, length.out=3)
c.rate<- seq(from=0.01, to =3, length.out=3)
p.shape<- seq(from=0.01, to =3, length.out=3)
p.rate<- seq(from=0.01, to =3, length.out=3)
param_grid <- expand.grid(
c.shape, c.rate, p.shape, p.rate
)
KL<- function(vec, no.d, Hset_b, Hset_g, prior_vec){
b_shape<-vec[1]
g_shape<- vec[2]
b_rate<- vec[3]
g_rate<- vec[4]
kl<-sum(sapply(1:5, function(k) mu_k(k,b_shape, g_shape,b_rate,g_rate, no.d, Hset_b, Hset_g)*log((1/prior_vec[k])*mu_k(k,b_shape, g_shape,b_rate,g_rate, no.d, Hset_b, Hset_g))))
return(kl)
}
collect_results<-matrix(nrow=2, ncol=8)
colnames(collect_results)<-c("type" ,"scenario", "C_shape", "C_rate", "P_shape", "P_rate", "divergence", "time_to_run")
set.seed(1001)
for(m in sc:sc){
j<-m
prior_vec<-prior_mat[j,]
t.grid<-system.time(
param_grid$score <- mapply(
KL_grid,
param_grid$Var1,
param_grid$Var2,
param_grid$Var3,
param_grid$Var4,
MoreArgs = list(prior_vec = prior_vec)
)
)
run_time_grid <- as.numeric(t.grid["elapsed"])
# Best parameters
best_params <- param_grid[which.min(param_grid$score), ]
input<-unlist(best_params)
if(length(unlist(best_params))==0){
input<-rep(NA, times=5)}
collect_results[1,]<-c("grid", j, input, run_time_grid)
### optimisation in paper
rate<- seq(from=0, to =2, length.out=100)
l <- data.frame(ac=NULL,ap=NULL, bc=NULL, bp=NULL, comb_div=NULL, clin_div=NULL, pat_div=NULL)
start_par <- c(1,1,1,1)
t.opt<-system.time(
nm <- nlminb(
start = start_par,
objective = KL,
lower = c(0, 0.1, 0, rate[i]),
upper = c(10, 10, 10, rate[i] + 0.01),
control = list(iter.max = 50,eval.max = 5000, rel.tol = 1e-8),
no.d = 5,Hset_b = clin,Hset_g = pat,prior_vec = prior_vec)
)
run_time_opt <- as.numeric(t.opt["elapsed"])
collect_results[2,]<-c("opt", j, unlist(nm$par), nm$objective, run_time_opt)
write.csv(collect_results, paste0("/home/ealger/revision_calibrate_priors/results/gridsearch/sc",j,".csv"))
}
sc<-3
